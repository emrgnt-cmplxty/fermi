// gdex
use gdex_types::{
    block::{Block, BlockInfo},
    json_rpc::{BlockInfoReply, BlockReply},
    proto::{BlockInfoRequest, LatestBlockInfoRequest, ValidatorGrpcClient},
    transaction::{deserialize_protobuf, BlockRequest, SignedTransaction},
    utils,
};
// mysten
use sui_json_rpc::SuiRpcModule;
use sui_open_rpc::Module;
use sui_open_rpc_macros::open_rpc;
// external
use jsonrpsee::core::{async_trait, Error, RpcResult};
use jsonrpsee::RpcModule;
use jsonrpsee_proc_macros::rpc;
use tokio::sync::Mutex;
use tonic::transport::Channel;

// To implement a custom RPC server, one starts with a trait that defines RPC methods
// The trait must be annotated with the `rpc` decorator.
// The methods must return a `Result` type.
// The `#[method(name = "foo")]` attribute is optional and results in a method named `{namespace}_foo`.
// If the attribute is not present, the method name is `{namespace}_{method_name}`.
#[open_rpc(namespace = "tenex", tag = "Primary RPC API")]
#[rpc(server, client, namespace = "tenex")]
pub trait Main {
    #[method(name = "submitTransaction")]
    async fn submit_transaction(&self, signed_transaction_bytes: String) -> RpcResult<String>;
    #[method(name = "getBlock")]
    async fn get_block(&self, block_number: u64) -> RpcResult<BlockReply>;
    #[method(name = "getBlockInfo")]
    async fn get_block_info(&self, block_number: u64) -> RpcResult<BlockInfoReply>;
    #[method(name = "getLatestBlockInfo")]
    async fn get_latest_block_info(&self) -> RpcResult<BlockInfoReply>;
}

// The JSONRPCService struct will implement the RPC server
// To do so, it must implement the trait `{TraitName}Server`
// this trait is generated by the rpc method above
// TODO -  - use RWLock
pub struct JSONRPCService {
    grpc_client: Mutex<ValidatorGrpcClient<Channel>>,
}

impl JSONRPCService {
    #[allow(clippy::new_without_default)]
    pub fn new(grpc_client: ValidatorGrpcClient<Channel>) -> Self {
        Self {
            grpc_client: Mutex::new(grpc_client),
        }
    }
}

#[async_trait]
impl MainServer for JSONRPCService {
    async fn submit_transaction(&self, signed_transaction_hex: String) -> RpcResult<String> {
        let signed_transaction_bytes: Vec<u8> = utils::decode_bytes_hex(&signed_transaction_hex)
            .map_err(|_| Error::Custom("Invalid transaction hex".to_string()))?;

        let signed_transaction: SignedTransaction = deserialize_protobuf(&signed_transaction_bytes)
            .map_err(|_| Error::Custom("Invalid transaction bytes".to_string()))?;

        self.grpc_client
            .lock()
            .await
            .submit_transaction(signed_transaction)
            .await
            .map_err(|e| Error::Custom(e.message().to_string()))?;
        Ok("Success".to_string())
    }

    async fn get_block(&self, block_number: u64) -> RpcResult<BlockReply> {
        let request = BlockRequest { block_number };
        let block_response = self
            .grpc_client
            .lock()
            .await
            .get_block(request)
            .await
            .map_err(|_| Error::Custom("Failed to fetch block from grpc".to_string()))?;

        let block: Block = bincode::deserialize(&block_response.into_inner().serialized_block)
            .map_err(|_| Error::Custom("Failed to decode block".to_string()))?;
        Ok(BlockReply::from(block))
    }

    async fn get_block_info(&self, block_number: u64) -> RpcResult<BlockInfoReply> {
        let request = BlockInfoRequest { block_number };
        let block_info_response = self
            .grpc_client
            .lock()
            .await
            .get_block_info(request)
            .await
            .map_err(|_| Error::Custom("Failed to fetch block info from grpc".to_string()))?;

        let block_info: BlockInfo = bincode::deserialize(&block_info_response.into_inner().serialized_block_info)
            .map_err(|_| Error::Custom("Failed to decode block".to_string()))?;
        Ok(BlockInfoReply::from(block_info))
    }

    async fn get_latest_block_info(&self) -> RpcResult<BlockInfoReply> {
        let request = LatestBlockInfoRequest {};

        let latest_block_info_response = self
            .grpc_client
            .lock()
            .await
            .get_latest_block_info(request)
            .await
            .map_err(|_| Error::Custom("Failed to fetch block info from grpc".to_string()))?;

        let block_info: BlockInfo =
            bincode::deserialize(&latest_block_info_response.into_inner().serialized_block_info)
                .map_err(|_| Error::Custom("Failed to decode block".to_string()))?;
        Ok(BlockInfoReply::from(block_info))
    }
}

// The SuiRPCModule allows us to generate an OpenRPC document for the RPC server.
impl SuiRpcModule for JSONRPCService {
    fn rpc(self) -> RpcModule<Self> {
        self.into_rpc()
    }

    fn rpc_doc_module() -> Module {
        crate::json_rpc::server::MainOpenRpc::module_doc()
    }
}
