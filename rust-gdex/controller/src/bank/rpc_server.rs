// IMPORTS

// crate

// local
use crate::router::ControllerRouter;
use gdex_types::store::RPCStoreHandle;
use gdex_types::{account::AccountPubKey, crypto::ToFromBytes, utils};

// mysten
use sui_json_rpc::SuiRpcModule;
use sui_open_rpc::Module;
use sui_open_rpc_macros::open_rpc;

// external
use jsonrpsee::core::{async_trait, Error, RpcResult};
use jsonrpsee::RpcModule;
use jsonrpsee_proc_macros::rpc;
use std::sync::{Arc, Mutex};

// To implement a custom RPC server, one starts with a trait that defines RPC methods
// The trait must be annotated with the `rpc` decorator.
// The methods must return a `Result` type.
// The `#[method(name = "foo")]` attribute is optional and results in a method named `{namespace}_foo`.
// If the attribute is not present, the method name is `{namespace}_{method_name}`.
#[open_rpc(namespace = "tenex", tag = "Primary RPC API")]
#[rpc(server, client, namespace = "tenex")]
pub trait ControllerData {
    #[method(name = "getAccountBalance")]
    async fn get_account_balance(&self, account: String, asset_id: u64) -> RpcResult<u64>;
}

// The JSONRPCService struct will implement the RPC server
// To do so, it must implement the trait `{TraitName}Server`
// this trait is generated by the rpc method above
// TODO -  - use RWLock
pub struct JSONRPCService {
    state_manager: Arc<Mutex<ControllerRouter>>,
}

impl JSONRPCService {
    #[allow(clippy::new_without_default)]
    pub fn new(state_manager: Arc<Mutex<ControllerRouter>>, _rpc_store_handle: Arc<RPCStoreHandle>) -> Self {
        Self { state_manager }
    }
}

#[async_trait]
impl ControllerDataServer for JSONRPCService {
    async fn get_account_balance(&self, account: String, asset_id: u64) -> RpcResult<u64> {
        let account_bytes: Vec<u8> = utils::decode_bytes_hex(&account)?;
        let account: AccountPubKey = AccountPubKey::from_bytes(account_bytes.as_slice())
            .map_err(|_| Error::Custom("Failed to decode market admin".to_string()))?;

        Ok(self
            .state_manager
            .lock()
            .unwrap()
            .bank_controller
            .lock()
            .unwrap()
            .get_balance(&account, asset_id)
            .unwrap_or(0))
    }
}

// The SuiRPCModule allows us to generate an OpenRPC document for the RPC server.
impl SuiRpcModule for JSONRPCService {
    fn rpc(self) -> RpcModule<Self> {
        ControllerDataServer::into_rpc(self)
    }

    fn rpc_doc_module() -> Module {
        crate::bank::rpc_server::ControllerDataOpenRpc::module_doc()
    }
}
